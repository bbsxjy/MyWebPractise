net start/stop mysql 来启动服务，cmd

mysql 后面+以下参数
-V 版本信息
-uroot 用户名 
-p 密码
-P 是端口码
-h 服务器名字

退出： quit exit \q
登录的时候加上--prompt可以修改提示符

\D 完整日期
\d 当前数据库
\h 服务器名称
\u 当前用户

显示版本日期用户
SELECT VERSION();
SELECT NOW();
SELECT USER();
用 SHOW DATABASES来查看所有数据库名字，然后用USE+名字
选择数据库，在用show tables来查看所有表名！

关键字，函数名称，都要大写
数据库，表，字段都要小写
分号结尾

SHOW WARNINGS是看错误信息的

创建数据库：
CREATE {DATABASE | SCHEMA} [IF NOT EXITSTS] db_name 
加了IF NOT EXITSTS就不会报错 
不设定编码方式，就是默认在ini文件里设定的
可以用CHARACTER SET charset_name

修改用：
ALTER {DATABASE | SCHEMA} [db_name] 
CHARACTER SET charset_name

删除用：
DROP {DATABASE | SCHEMA} [IF EXITSTS] db_name 

数据类型
INT类：
TINY,SMALL,MEDIUN,INT,BIG INT
2^8,2^16,2^24,2^32,2^64
字节，1,2,3,4,8

float类：
FLOAT[(M,D)]----M是数字总位数，D是小数点后的位数 E38
DOUBLE[(M,D)]----E308

日期类：
YEAR-1970-2069年
TIME-8385959-8385959
DATE-1000-9999年
DATETIME-1000年的0点-9999年12月31的0点
TIMESTAMP-1970-2037
一般会用timestamp或者数字的方法来储存信息

字符型：
CHAR(M):M个字节 0-255，会自动补偿
VARCHAR(M)：存储定长 L+1，L<=M,M->0-65535
TINYTEXT：存储定长 L+1，L<=2^8
TEXT：存储定长 L+2，L<=2^16
MEDIUMTEXT：存储定长 L+3，L<=2^24
LONGTEXT：存储定长 L+4，L<=2^32
ENUM('VALUE1','VALUE2'...) 1/2个字节，最多65535个枚举值
SET('VALUE1','VALUE2'...) 取决于成员数，最多64个成员

数据表是数据库的组成部分：
USE+数据库名称-------打开数据库

创建数据表(得事先设计好了，再进行填写)：
CREATE TABLE [IF NOT EXITSTS] table_name(
  column_name data_type,
  ...
)

查看数据表：
SHOW TABLES [FROM db_name]
查看数据表结构：
SHOW COLUMNS FROM tbl_name

写入：
INSERT [INTO] tbl_name [(col_name)] VALUES(val,...)

查找：
SELECT EXPR,... FROM TBL_NAME

主键 PRIMARY KEY：
*一张表只有一个主键*
保证记录唯一性，自动为NOT NULL
创建：CREATE TABLE tb3(
    -> id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    -> username VARCHAR(30) NOT NULL
    -> );
结果就是：
+----------+----------------------+------+-----+---------+----------------+
| Field    | Type                 | Null | Key | Default | Extra          |
+----------+----------------------+------+-----+---------+----------------+
| id       | smallint(5) unsigned | NO   | PRI | NULL    | auto_increment |
| username | varchar(30)          | NO   |     | NULL    |                |
+----------+----------------------+------+-----+---------+----------------+
之后每一条记录，每个id会自动增加。
**重要：
AUTO INCREAMENT 必须为主键，但是主键创建时候可以选择不添加此功能

主键的唯一约束：
UNIQUE KEY，字段可以为空
*每张表可以存在多个唯一约束*
创建：> CREATE TABLE tb5
    -> (
    -> id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    -> username VARCHAR(20) NOT NULL UNIQUE KEY,
    -> age tinyint UNSIGNED)
    -> ;
结果就是:
+----------+----------------------+------+-----+---------+----------------+
| Field    | Type                 | Null | Key | Default | Extra          |
+----------+----------------------+------+-----+---------+----------------+
| id       | smallint(5) unsigned | NO   | PRI | NULL    | auto_increment |
| username | varchar(20)          | NO   | UNI | NULL    |                |
| age      | tinyint(3) unsigned  | YES  |     | NULL    |                |
+----------+----------------------+------+-----+---------+----------------+

默认约束：
如果插入记录的时候，没有个字段赋值，则自动赋予默认值
创建： ...
      variable name ENUM（‘1’，‘2’，‘3’）DEFAULT '3'


外键约束（物理不常用，主逻辑）：
1.父表子表必须要用相同的存贮引擎，无法使用临时表
2.引擎只能是InnoDB
3.外检咧和参照咧必须具有相似的数据类型。其中数字长度和符号位必须相同，但是字符的长度则可以不同
4.外检列和参照咧必须创建索引，如果外检列不存在索引，则自动创建（只为参照列创建）

用SHOW CREATE TABLE + TABLE NAME查看所用引擎
用SHOW INDEXES FROM +TABLE NAME\G 查看是否有索引

在下列例子中，pid是外检，id是参照
> CREATE TABLE users(
    -> id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
    -> username VARCHAR(10) NOT NULL,
    -> pid SMALLINT UNSIGNED,
    -> FOREIGN KEY (pid) REFERENCES province(id)
    -> );
参照操作：
-> FOREIGN KEY (pid) REFERENCES province(id) ON DELETE 后面加
CASCADE: 从父表中删除或者更新的时候，同时删除或者更新子表中匹配行
SET NULL: 从父表中删除或者更新的时候，同时设置子表中的外检列为NULL，但是若此列已设置为NOT NULL 则操作不成功
RESTRICT: 拒绝和父表同步


只针对一个约束，叫列级约束，声明可以在语句前后
针对2个或2个以上的叫表级约束，声明只能再列定义后

添加单列：
ALTER TABLE TABL_NAME ADD [COLUMN] COL_NAME COLUMN_DEFINITION [FIRST（所有列的最前面） | AFTER（默认） COL_NAME]：
例：ALTER TABLE user ADD age VARCHAR(20) NOT NULL AFTER username；
添加多列：
ALTER TABLE TBL_NAME ADD [COLUMN] (COL_NAME COLUMN_DEF) 只能添加于所有列的后面

删除单列或多列：
ALTER TABLE TBL_NAME DROP [COLUMN] COL_NAME
用逗号分隔： ALTER TABLE user DROP password， DROP age；

添加约束：
主键约束ALTER TABLE TBK_NAME ADD[CONSTRAINT [SYMBOL]] PRIMARY KEY [INDEX_TYPE] (INDEX_COL_NAME...)
例：ALTER TABLE user2 ADD CONSTRAINT PK_USERS2_ID(主键名字) PRIMARY KEY(id)

唯一约束ALTER TABLE TBL_NAME ADD [CONSTRAINT [SYMBOL]] UNIQUE [INDEX|KEY] [INDEX_NAME] [INDEX_TYPE] (INDEX_COL_NAME) (INDEX_COL_NAME...)
例:ALTER TABLE USER2 ADD UNIQUE (USERNAME)

外键约束ALTER TABLE TBL_NAME ADD [CONSTRAINT [SYMBOL]] FOREIGN KEY [INDEX_NAME]  (INDEX_COL_NAME...) REFERENCE_DEFINITION
例：ALTER TABLE USER2 ADD FOREIGN KEY (PID) REFERENCES PROVINCE (ID);

添加或者删除默认约束
ALTER TABLE TBL_NAME ALTER [COLUMN] col_name {SET DEFAULT literal | DROP DEFAULT}
例： ALTER TABLE usre ALTER age SET DEFAULT 15

删除主键约束：
ALTER TABLE TBK_NAME DROP PRIMARY KEY
删除唯一约束：
ALTER TABLE TBK_NAME DROP {INDEX|key} username
删除外键约束：
ALTER TABLE TBK_NAME DROP FOREIGN KEY FK_SYMBOL(约束名)

修改数据表：
修改列定义（数据类型，或者位置） ALTER TABLE TBL_NAME MODIFY [COLUMN] COL_NAME COLUMN_DEF [FIRST|AFTER COL_NAME]
例： ALTER TABLE TBL_NAME MODIFY id SAMLLINT UNSIGNED NOT NULL FIRST
修改列名称：ALTER TABLE TBL_NAME CHANGE [COLUMN] OLD_COL+NAME NEW_COLNAME COLUMN_DEF [FIRST | AFTER COL_NAME]
修改数据表名：
ALTER TABLE TBL_NAME RENAME NEW_NAME； RENAME TABLE TBL_NAME TO NEW_TB_NAME

插入记录
INSERT table_name VALUES（NULL/DEFAULT,'..'）;
如果是NULL或者DEFAULT则自动递增
不常用：INSERT USERS SET USERNAME='',PW='';这个可以用来子查询
**用INSERT TEST(USERNAME) SELECT username FROM USERS WHERE age》=30
可以将USER表里的username年龄大于30的写到新表test里**

更新记录
单表更新UPDATE users set age=age+5；//所有age记录+5 
用WHERE语句挑选记录：UPDATE USERS SET AGES=AGES+10 WHERE ID%2=0;

删除操作：
DELETE FROM tabl_name 【where condition】

查找记录：
SELECE select_exp
可以直接计算结果
SELECT var1,var2 FROM TABLE_NAME var的顺序将影响结果的顺序
赋予别名：SELECT ID AS XXX, USERNAME AS KKK FROM USERS同样影响结果

条件表达式：
对记录进行过滤，如果不指定where将对所有记录进行操作
可加函数或者运算符

GROUP BY 结果分组：
[GROUP BY {COL_N |POSITION}] [ASC|DESC](升降序)
SELECT sex FROM users GROUP BY sex 对结果进行分组，相当于统计种类  

HAVING WHERE CONDITION
SELECT sex,age FROM users GROUP BY sex HAVING AGE>35（必须要在SELECT里面选上，只能有一个返回值得条件）

ORDER BY 对结果排序：
【order by{col_name|expr|position} 【ASC|DESC】，...】
SELECT *FROM USERS ORDER BY ID DESC
SELECT *FROM USERS ORDER BY AGE,ID DESC(同时使用排序方法)

LIMIT语句：
限制查寻结果返回数量
[LIMIT {[offset]row_count | row_count OFFSET offset}]
OFFESET计算公式：分页效果，（当前页码-1）*每页所显示的记录数
例：SEKECT * FROM USERS LIMIT 2(从头开始);
SEKECT * FROM USERS LIMIT 2，2(从第二条开始);与ID不同
